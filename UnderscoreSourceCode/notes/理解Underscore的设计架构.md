# 理解Underscore的设计架构

在一个多月的毕业设计之后，我再次开始了Underscore的源码阅读学习，断断续续也写了好些篇文章了，基本把一些比较重要的或者个人认为有营养的函数都解读了一遍，所以现在学习一下Underscore的整体架构。我相信很多程序员都会有一个梦想，那就是可以写一个自己的模块或者工具库，那么我们现在就来学习一下如果我们要写一个自己的Underscore，我们该怎么写？

大致的阅读了一下Underscore源码，可以发现其基本架构如下：

## 1 定义变量

在ES6之前，JavaScript开发者是无法通过let、const关键字模拟块作用域的，只有函数内部的变量会被认为是私有变量，在外部无法访问，所以大部分框架或者工具库的模式都是在立即执行函数里面定义一系列的变量，完成框架或者工具库的构建，这样做的好处就是代码不会污染全局作用域。Underscore也不例外，它也使用了经典的立即执行函数的模式：

    (function() {
        // ...
    }())



此外，Underscore采用了经典的构造器模式，这使得用户可以通过`_(obj).function()`的方式使用Underscore的API，因为任意创建的Underscore对象都具有原型上的所有方法。那么代码形式如下：

    (function() {
        var _ = function() {
            // ...
        };
    }())

_是一个函数，但是在JavaScript中，函数也是一个对象，所以我们可以给_添加一系列属性，即Underscore中的一系列公开的API，以便可以通过`_.function()`的形式调用这些API。代码形式如下：

    (function() {
        var _ = function() {
            // ...
        };
        _.each = function() {
            // ...
        };
        // ...
    }())

## 2 导出变量
既然我们是在立即执行函数内定义的变量，那么_的生命周期也只存在于匿名函数的执行阶段，一旦函数执行完毕，这个变量所存储的数据也就被释放掉了，所以不导出变量的话实际上这段代码相当于什么都没做。那么该如何导出变量呢？我们知道函数内部可以访问到外部的变量，所以只要把变量赋值给外部作用域或者外部作用域变量就行了。通常为了方便实用，把变量赋值给全局作用域，不同的环境全局作用域名称不同，浏览器环境下通常为window，服务器环境下通常为global，根据不同的使用环境需要做不同的处理，比如浏览器环境下代码形式如下：

    (function() {
        var _ = function() {
            // ...
        };
        _.each = function() {
            // ...
        };
        // ...
        window._ = _;
    }())

这样处理之后，在全局作用域就可以直接通过_使用Underscore的接口了。

但是仅仅这样处理还不够，因为Underscore面向环境很多，针对不同的环境要做不同的处理。接下来看Underscore源码。

首先，Underscore通过以下代码根据不同的环境获取不同的全局作用域：

    //获取全局对象，在浏览器中是self或者window，在服务器端（Node）中是global。
	//在浏览器控制台中输入self或者self.self，结果都是window。
	var root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || this || {};

注释写在了代码中，如果既不是浏览器环境也不是Node环境的话，就获取值为this，如果this仍然为空，就赋值给一个空的对象。这里我不太明白赋值给空对象有什么意义，这样的话外部还是无法访问到这个对象的，如果有知道的童鞋欢迎在评论中告诉我，大家一起学习！

这里值得学习的地方还有作者关于赋值的写法，十分简洁，尝试了一下，对于下面的写法：

    const flag = val1 && val2 && val3 || val4 && val5;

程序会从左到右依次判断val1、val2、val3的值，假设`||`把与运算分为许多组，那么：
* 一旦当前判断组的某个值转换为Boolean值后为false，那么就跳转到下一组进行判断，直到最后一组，如果最后一组仍然有值被判断为false，那么为false的值被赋给flag。
* 如果当前判断组所有的值转换后都为true，那么最后一个值会被赋给flag。

比如：

    const a = 1 && 2 && 3 || 2 && 3;
    // a === 3
    const b = 1 && false && 2 || 2 && 3;
    // b === 3
    const c = 1 && false && 2 || false && 2
    // c === false
    const d = 1 && false && 2 || 0 && 2
    // d === 0
    const e = 1 && false && 2 || 1 && 2
    // e === 2

